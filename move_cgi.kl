-- http://<robot_ip>/KAREL/move_cgi?io_op=write&p={x,y,z,w,p,r}
-- http://<robot_ip>/KAREL/move_cgi?io_op=read => {"result":"success","op":"read","pose":[x,y,z,w,p,r]}

PROGRAM move_cgi

%COMMENT = 'v4'
%NOLOCKGROUP
%NOPAUSE=ERROR+COMMAND+TPENABLE
%NOBUSYLAMP

CONST
	RPC_FILE	= 'TD:\RESPONSE.HTM'
	RPC_OMODE	= 'RW'

	OP_READ 	= 'read'
	OP_WRITE	= 'write'

VAR
	fd_		: FILE
	stat_		: INTEGER

	pose		: XYZWPREXT
	tmppose		: XYZWPR

	-- GET PARAMETERS
	io_op		: STRING[16]	-- operatior or used method
	p		    : STRING[254]	-- position string {p=x,y,z,w,p,r}

ROUTINE w_error(fd: FILE; reason: STRING)				  FROM move_cgi
ROUTINE check_param 	      	 				: INTEGER FROM move_cgi
ROUTINE str2pose(str:STRING; del:STRING; pose: XYZWPR)           FROM move_cgi
ROUTINE split_str(str:STRING; del:STRING; res:ARRAY[*] OF STRING) FROM move_cgi
ROUTINE real2str(r : REAL)                : STRING FROM move_cgi
ROUTINE lstrip(s : STRING)                : STRING FROM move_cgi

BEGIN
	OPEN FILE fd_(RPC_OMODE,RPC_FILE)

	stat_ = IO_STATUS(fd_)
	IF (stat_ <> 0) THEN
	   w_error(fd_,'no status')
	   p = ''
	   CLOSE FILE fd_
	ENDIF

	IF (check_param <> 0) THEN
	   p = ''
	   CLOSE FILE fd_
	ENDIF

	-- init pose with current possition
	pose = CURPOS(0,0)

	   -- read
	IF (io_op = OP_READ) THEN
	   -- read request
	   -- write return to the http server
	   WRITE fd_('{',
		     '"result":"success",',
		     '"op":"read",',
		     '"position":[',
		     real2str(pose.x), ',',
		     real2str(pose.y), ',',
		     real2str(pose.z), ',',
		     real2str(pose.w), ',',
		     real2str(pose.p), ',',
		     real2str(pose.r),
		     ']}')
	   
	ELSE
	
		--write
		IF (io_op = OP_WRITE) THEN
		   --check p string
		   IF (UNINIT(p)) THEN
		      w_error(fd_, 'missing parameter: p')
		      p = ''
	   	      CLOSE FILE fd_
		   ENDIF

		   IF (UNINIT(tmppose)) THEN
		   	  tmppose.x = pose.x
		   	  tmppose.y = pose.y
		   	  tmppose.z = pose.z
		   	  tmppose.w = pose.w
		   	  tmppose.p = pose.p
		   	  tmppose.r = pose.r
		   ENDIF

		   str2pose(p,',',tmppose)

		   IF (UNINIT(pose)) THEN
		   	  w_error(fd_, 'pose not inizialized')
		      p = ''
	   	      CLOSE FILE fd_
		   ENDIF

		   pose.x = tmppose.x
		   pose.y = tmppose.y
		   pose.z = tmppose.z
		   pose.w = tmppose.w
		   pose.p = tmppose.p
		   pose.r = tmppose.r
		   	     
		   --move_to
		   $MOTYPE = JOINT
		   MOVE TO pose
		   	
		    WRITE fd_('{',
		     '"result":"success",',
		     '"op":"write",',
		     '"position":[',
		     real2str(pose.x), ',',
		     real2str(pose.y), ',',
		     real2str(pose.z), ',',
		     real2str(pose.w), ',',
		     real2str(pose.p), ',',
		     real2str(pose.r),
		     ']}')
		   	
		ELSE
		--anything else corse error
		   w_error(fd_, 'unsupported method:' + io_op)
		   p = ''
	   	   CLOSE FILE fd_
		ENDIF
	   
	ENDIF

END move_cgi

ROUTINE check_param
BEGIN
	IF ((UNINIT(io_op) )) THEN io_op = '' ; ENDIF
	-- p is allowed to be empty
	IF ((UNINIT(p) ))     THEN p 	 = '' ; ENDIF

	IF (io_op = '') THEN
	   w_error(fd_,'options empty')
	   RETURN (-1)
	ENDIF

	RETURN(0)
END check_param

ROUTINE w_error
BEGIN
	WRITE fd('{"result":"error","reason":"', reason, '"}',CR)
END w_error

ROUTINE split_str
  VAR
    tmp : STRING[254]
    i   : INTEGER
    j   : INTEGER
  BEGIN
    j = 1
    tmp = ''

    -- initialize empty string array
    FOR i = 1 TO ARRAY_LEN(res) DO
      res[i] = ''
    ENDFOR

    FOR i = 1 TO STR_LEN(str) DO
      IF (i = STR_LEN(str)) AND (SUB_STR(str,i,1) <> del) THEN
        tmp = tmp + SUB_STR(str,i,1)
      ENDIF

      IF (SUB_STR(str,i,1) = del) OR (i = STR_LEN(str)) THEN
        res[j] = tmp
        j = j + 1
        tmp = ''
      ELSE
        tmp = tmp + SUB_STR(str,i,1)
      ENDIF
    ENDFOR
  END split_str


ROUTINE str2pose
VAR
	cpos : ARRAY[6] OF STRING[10]
BEGIN
	split_str(str, del, cpos)
	
	CNV_STR_REAL(cpos[1],pose.x)
	CNV_STR_REAL(cpos[2],pose.y)
	CNV_STR_REAL(cpos[3],pose.z)
	CNV_STR_REAL(cpos[4],pose.w)
	CNV_STR_REAL(cpos[5],pose.p)
	CNV_STR_REAL(cpos[6],pose.r)	
END str2pose

ROUTINE real2str
  VAR
    s : STRING[16]
    i : INTEGER
  BEGIN
    IF UNINIT(r) THEN
      RETURN('null')
    ENDIF

    CNV_REAL_STR(r, 0, 3, s)
    s = lstrip(s)

    -- watchout for negative number
    IF SUB_STR(s,1,1) = '-' THEN
      -- see if next char is a point .
      IF SUB_STR(s,2,1) = '.' THEN
        s = '-0.' + SUB_STR(s,3,STR_LEN(s))
      ENDIF
    ENDIF

    -- add leading zero
    IF SUB_STR(s,1,1) = '.' THEN
      s = '0' + s
    ENDIF

    -- get rid of trailing zeroes
    FOR i = STR_LEN(s) DOWNTO 1 DO
      IF SUB_STR(s,i,1) <> '0' THEN
        -- see if prev char is a . so we leave 1 trailing zero
        IF SUB_STR(s,i,1) = '.' THEN
          RETURN(SUB_STR(s,1,i+1))
        ELSE
          RETURN(SUB_STR(s,1,i))
        ENDIF
      ENDIF
    ENDFOR

    RETURN(s)
  END real2str

ROUTINE lstrip
  VAR
    i : INTEGER
  BEGIN
    FOR i = 1 TO STR_LEN(s) DO
      IF SUB_STR(s,i,1) <> ' ' THEN
        RETURN(SUB_STR(s,i,STR_LEN(s)))
      ENDIF
    ENDFOR

    RETURN(s)
  END lstrip
